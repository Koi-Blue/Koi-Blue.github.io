# 0 写在前面
&nbsp;
&ensp;&ensp;&ensp;&ensp;找到适应自己的工作节奏以及合作伙伴将是高效完成项目的前提。
> by the way 本文不具体展示机械结构设计部分，原因是小鱼不具有该部分的版权 :  (
# 1 功能描述
&nbsp;
&ensp;&ensp;&ensp;&ensp;通过一键启动的（没错是鼠标，不过添加一个按键事件也是一件不难的事）自动起重机器人，对于一定范围内的重物（本文仅针对单钩砝码，是的，秤砣）进行自动识别并通过抓手进行抓取，抓取后需要将该重物放置到固定点位，至此为完成了对该重物的作业；下文将从外向里依次解决自动化的实现问题。
## 1.1 机架的水平移动
&nbsp;
&ensp;&ensp;&ensp;&ensp;机架的核心抓取部分（即抓手），并不是每时每刻都处于每一次作业的理想位置的，所以要完成作业固然少不了：跑过来，跑过去。
## 1.2 抓手起降
&nbsp;
&ensp;&ensp;&ensp;&ensp;在作业中难免发生目标位置的高度不一致的问题，针对本问题即为抓取单钩砝码的高度与放置高度并不一致，且需要一定程度的避免碰撞和拖地等问题，上下移动将是完成任务的又一重点。
## 1.3 抓手的抓取作业
&nbsp;
&ensp;&ensp;&ensp;&ensp;不把东西拿起来，靠意念是不能作业的 ：）
## 1.4 计算机视觉
&nbsp;
&ensp;&ensp;&ensp;&ensp;摸黑在房间走路也难免踢到床头，不具备视觉的起重机将更加抓瞎（固化方案将消耗更多能源与时间），视觉将是灵魂一举。
## 1.5 把他们串起来
&nbsp;
&ensp;&ensp;&ensp;&ensp;我猜你也不希望车子爪子各玩儿各的吧。
&nbsp;
# 2 功能实现
&nbsp;
&ensp;&ensp;&ensp;&ensp;好的我们已经知道了需要哪些部分才能赋我们的起重机以赛博生命，坐上小鱼的老爷车，一起来看看吧！
# 2.1 机架的水平移动
&nbsp;
&ensp;&ensp;&ensp;&ensp;水平移动有两种主流方案，一是小车型（大多采用[麦克纳姆轮小车](https://wiki-power.com/%E9%BA%A6%E8%BD%AE%E5%B0%8F%E8%BD%A6)，相信你知道这是什么），另一是[龙门架](https://baike.baidu.com/item/%E9%BE%99%E9%97%A8%E6%9E%B6/6163984)结构，我们针对龙门式展开；相信你现在已经有了自己理想的移动方案，或是主动轮转动，或是齿轮履带拉动，这些都好，只不过需要注意的是：我们的轮子或齿轮需要像汽车的主动轮同样是左右对称的，这将拯救松散的车架和瘪瘪的钱包。
&nbsp;
&ensp;&ensp;&ensp;&ensp;因为考虑到转速、扭矩，最重要的还有经费问题，我们最终采用了两块57步进电机和一块42步进电机，驱动板型号为DM542（经费充足的条件下可以选择扭力更大，转速更加优秀的直流电机）。**在这里统一说明**，该项目的上位机平台为一块树莓派4B，下位机均为arduino_uno。在这里将三块电机与驱动板正确连接后，将驱动板与arduino连接。
~~~C
#include <AccelStepper.h>

// 定义步进电机和引脚
#define dirPin1 4
#define stepPin1 3
#define dirPin2 6
#define stepPin2 5
#define dirPin3 8
#define stepPin3 7

AccelStepper stepper1(AccelStepper::DRIVER, stepPin1, dirPin1);
AccelStepper stepper2(AccelStepper::DRIVER, stepPin2, dirPin2);
AccelStepper stepper3(AccelStepper::DRIVER, stepPin3, dirPin3);

void setup() {
  Serial.begin(115200);
  stepper1.setMaxSpeed(1000000);
  stepper1.setAcceleration(10000);
  stepper2.setMaxSpeed(1000000);
  stepper2.setAcceleration(10000);
  stepper3.setMaxSpeed(5000);
  stepper3.setAcceleration(800);
}

void loop() {
  if (Serial.available() > 0) {
    String inputString = Serial.readStringUntil('\n'); // 读取输入字符串
    if (inputString.length() == 9) { // 确保输入字符串长度为9
      char motorCode = inputString.substring(0, 2).toInt();
      char direction = inputString.substring(2, 4).toInt();
      int steps = inputString.substring(4).toInt();

      if (motorCode == 1) { // 控制步进电机1和2
        if (direction == 0) {
          stepper1.move(steps);
          stepper2.move(-steps);
        } else {
          stepper1.move(-steps);
          stepper2.move(steps);
        }
      } else if (motorCode == 3) { // 控制步进电机3
        if (direction == 0) {
          stepper3.move(steps);
        } else {
          stepper3.move(-steps);
        }
      }

      // 开始运动步进电机
      while (stepper1.distanceToGo() != 0 || stepper2.distanceToGo() != 0 || stepper3.distanceToGo() != 0) {
        stepper1.run();
        stepper2.run();
        stepper3.run();
      }
    }
  }
}
~~~
&ensp;&ensp;&ensp;&ensp;以上是步进电机部分的下位机代码，可以直接在arduinoIDE中烧录给板子；我们从速度开始：
~~~C
void setup() {
  Serial.begin(115200);
  stepper1.setMaxSpeed(1000000);
  stepper1.setAcceleration(10000);
  stepper2.setMaxSpeed(1000000);
  stepper2.setAcceleration(10000);
  stepper3.setMaxSpeed(5000);
  stepper3.setAcceleration(800);
}
~~~
&ensp;&ensp;&ensp;&ensp;其中波特率部分很好理解，相信大家都熟悉了；由于考虑到电机启动时的同步轮（轮子）打滑问题，再不断地尝试下，确定了分别对应于不同型号的步进电机的加速度，至于速度上限，可以根据实际运行情况进行尝试，这里因为缓启动解决了打滑问题，而我们希望尽可能快速地完成任务，所以对于速度上限的设定远超于实际最大速度。
&ensp;&ensp;&ensp;&ensp;后面的控制逻辑即为要点，要看懂这里如何应用，不得不放出上位机代码了：
~~~python
import serial
import time

def send_command(ser, command):
    ser.write(command.encode())
    ser.write(b'\n')  # 发送换行符来结束命令
    print(f"Sent command: {command}")

def main():
    port = 'COM7'  # Arduino连接的串口端口（此处为PC端测试接口，如果上位机为linux系统，大多为ttyACM*）
    baudrate = 115200  # 确保与Arduino设置的波特率一致

    try:
        ser = serial.Serial(port, baudrate, timeout=1)
        time.sleep(2)  # 等待串口稳定

        while True:
            command = input("Enter command (9 characters, e.g., 010002000): ")

            if len(command) == 9:
                send_command(ser, command)
            else:
                print("Invalid input. Please enter a 9-character string.")

    except serial.SerialException as e:
        print(f"Error: {e}")
    finally:
        if ser.is_open:
            ser.close()

if __name__ == "__main__":
    main()
~~~
&ensp;&ensp;&ensp;&ensp;不难发现，在步进电机的控制下，我预留了一个9位数接口，

|1，2位|3，4位|其余五位|
|:--------------------------------------------:|:-----------------------:|:--------------------:|
|01 or 03|00 or 01|04750|
|01代表步进电机1和2，03代表步进电机3|00和01代表不同方向|运行04750步|
> 单选题10题10分
> 判断题10题10分
> 填空题10空10分（有难题，不会可空）
> 简答题2个 10/20 概念＋举例约6行
> 应用题3个题多问，一题中每问5或6分
> 三、六和七章占比较大

---
# 第一章

## 1.2.7 关系模型与其他区别
$\qquad$ 关系模型建立在严格的**数学概念**的基础上，从用户的观点看，**关系模型由一组关系组成**；每个关系的数据结构是一张规范化的二维表；
**关系：** 一个关系对应通常说的一张表；
**关系模式：** 对关系的描述，一般表示为

-	关系名 （属性1， 属性2， ...，属性n）

**例如**

-	学生（学号， 姓名， 年龄， 性别， 系名， 年级）

**关系模型**	

1. 要求关系必须是规范化的，关系必须满足一定的规范条件，关系的每一个分量必须是一个不可分的数据项；
2. 关系模型的数据操纵主要包括查询、插入、删除和更新数据；这些操作必须满足关系的完整性约束条件；
3. 关系模型中的数据操作是集合操作，操作对象和操作结果都是关系；
4. 关系模型把存取路径向用户隐蔽起来，用户只要指出“干什么”或“找什么”， 不必详细说明“怎么干”或“怎么找”。

**关系模型优缺点：**

1. 关系模型建立在严格的数学概念基础上；
2. 关系模型的概念单一；
3. 关系模型的存取路径对用户透明；
4. 存取路径对用户是隐蔽的，查询效率往往不如格式化数据模型

## 1.3.2数据库的三级模式结构（p28）
* 由模式、外模式、内模式三级构成

1. 模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图；
2. 外模式也称子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示；
3. 内模式也称存储模式，一个数据库只有一个内模式，他是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。

---
# 第二章
## 2.3 关系的完整性
### 2.3.1 实体完整性
**定义**：实体完整性确保表中的每一行都是唯一的，即主键值必须唯一且不能为空。
**例子**：
假设有一个 **students** 表，其结构如下：
``` sql
CREATE TABLE students (
    student_id INT PRIMARY KEY,  -- 学生ID，主键
    name VARCHAR(100) NOT NULL,  -- 学生姓名
    age INT,                     -- 年龄
    gender CHAR(1)               -- 性别
);
```
在这个表中，`student_id` 是主键，必须满足以下条件：
- 每个 `student_id` 必须是唯一的。
- `student_id` 不能为 `NULL` 。

### 2.3.2 参照完整性
**定义**：参照完整性确保两个表之间的关系是正确的，即外键值必须引用主键表中存在的值。
**例子**：
假设有两个表 `departments` 和 `employees`，其中 `employees` 表中的 `department_id` 是一个外键，引用 `departments` 表的 `department_id`。
``` sql
-- 创建 departments 表
CREATE TABLE departments (
    department_id INT PRIMARY KEY,  -- 部门ID，主键
    department_name VARCHAR(100) NOT NULL  -- 部门名称
);

-- 创建 employees 表
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,    -- 员工ID，主键
    name VARCHAR(100) NOT NULL,     -- 员工姓名
    hire_date DATE,                 -- 入职日期
    salary DECIMAL(10, 2),          -- 薪资
    department_id INT,              -- 部门ID，外键
    FOREIGN KEY (department_id) REFERENCES departments(department_id)
);
```
在这个例子中，参照完整性规则确保：
- `employees` 表中的 `department_id` 必须引用 `departments` 表中存在的 `department_id`。
- 如果尝试插入一个不存在于 `departments` 表中的 `department_id`，将会引发错误。

### 2.3.3 用户定义的完整性
**定义**：用户定义的完整性是指用户根据业务需求定义的特定规则和约束，这些规则可能不在标准的完整性类型范围内。
**例子**：
假设有一个 `orders` 表，需要确保订单金额大于0，并且订单状态必须是 `'Pending'` , `'Shipped'` , 或 `'Delivered'` 。
``` sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,       -- 订单ID，主键
    customer_id INT,                -- 客户ID
    order_amount DECIMAL(10, 2) CHECK (order_amount > 0),  -- 订单金额，必须大于0
    order_status VARCHAR(20) CHECK (order_status IN ('Pending', 'Shipped', 'Delivered')),  -- 订单状态
    order_date DATE                 -- 订单日期
);
```
在这个表中，用户定义的完整性规则包括：
- `order_amount` 列必须大于0。
- `order_status` 列只能是 `'Pending'` , `'Shipped'` , 或 `'Delivered'` 。

## 2.4 关系代数（写出代数公式，明白是什么意思 或反）

- 关系代数是抽象查询语言，他用对关系的运算来查询表达；
- 关系代数的运算按运算符的不同可分为传统的集合运算和专门的关系运算两类

---
# 第三章 SQL

**对于多个表需要了解**

- 创建一个表，确定数据类型、表头（字段名）、数据类型长度；
- 多表查询： 连接查询或嵌套查询，随意；
- 视图检索；
- 修改表，检索表；
- 视图消解发（上网搜）定义，特点，步骤；

**实现**
### 1. 创建表
创建两个表：`students` 和 `courses` 。
**`students` 表**
``` sql
-- 创建 students 表
CREATE TABLE students (
    student_id INT PRIMARY KEY,          -- 学生ID，主键
    name VARCHAR(100) NOT NULL,         -- 学生姓名
    age INT,                            -- 年龄
    gender CHAR(1),                     -- 性别，M 或 F
    major VARCHAR(50)                   -- 专业
);
```
**`courses` 表**
``` sql
-- 创建 courses 表
CREATE TABLE courses (
    course_id INT PRIMARY KEY,          -- 课程ID，主键
    course_name VARCHAR(100) NOT NULL,  -- 课程名称
    credits INT,                        -- 学分
    department VARCHAR(50)              -- 开课院系
);
```
### 2. 多表查询
创建一个关联表 `enrollments` ，记录学生选课的情况。
**`enrollments` 表**
``` sql
-- 创建 enrollments 表
CREATE TABLE enrollments (
    enrollment_id INT PRIMARY KEY,      -- 报名ID，主键
    student_id INT,                     -- 学生ID，外键
    course_id INT,                      -- 课程ID，外键
    grade DECIMAL(5, 2),                -- 成绩
    FOREIGN KEY (student_id) REFERENCES students(student_id),
    FOREIGN KEY (course_id) REFERENCES courses(course_id)
);
```
**连接查询**
``` sql
-- 查询所有学生的选课情况
SELECT 
    s.student_id,
    s.name,
    c.course_id,
    c.course_name,
    e.grade
FROM 
    students s
JOIN 
    enrollments e ON s.student_id = e.student_id
JOIN 
    courses c ON e.course_id = c.course_id;
```
**嵌套查询**
``` sql
-- 查询所有选修了“计算机科学”课程的学生姓名
SELECT 
    s.name
FROM 
    students s
WHERE 
    s.student_id IN (
        SELECT 
            e.student_id
        FROM 
            enrollments e
        JOIN 
            courses c ON e.course_id = c.course_id
        WHERE 
            c.course_name = '计算机科学'
    );
```
### 3. 视图检索
创建一个视图来简化复杂的查询。
``` sql
-- 创建视图 student_courses
CREATE VIEW student_courses AS
SELECT 
    s.student_id,
    s.name,
    c.course_id,
    c.course_name,
    e.grade
FROM 
    students s
JOIN 
    enrollments e ON s.student_id = e.student_id
JOIN 
    courses c ON e.course_id = c.course_id;

-- 使用视图查询
SELECT * FROM student_courses WHERE grade > 80;
```
### 4. 修改表、检索表
**修改表**
``` sql
-- 添加一个新的字段到 students 表
ALTER TABLE students ADD COLUMN email VARCHAR(100);

-- 修改字段的数据类型
ALTER TABLE students MODIFY COLUMN age SMALLINT;

-- 删除一个字段
ALTER TABLE students DROP COLUMN email;
```
**检索表**
``` sql
-- 查询 students 表中的所有记录
SELECT * FROM students;

-- 查询 courses 表中的所有记录
SELECT * FROM courses;
```
### 视图消解法

**定义**

视图消解法`（View Resolution）`是**将视图查询转换为对基表的查询**的过程。这种方法可以**提高查询性能**，因为直接对基表进行操作通常比通过视图更高效。

**特点**

- **提高性能**：直接操作基表避免了视图的额外开销。
- **灵活性**：可以在基表上进行更复杂的优化。
- **透明性**：对用户来说，视图仍然是一个抽象层，但底层的查询已经被优化。

**步骤**

- **分析视图定义**：查看视图的定义，理解视图是如何从基表中提取数据的。
- **提取基表查询**：将视图定义中的查询逻辑提取出来，形成对基表的查询。
- **优化查询**：根据具体的需求和数据结构，优化提取出来的查询。
- **测试和验证**：确保优化后的查询结果与视图查询结果一致。

---
# 第四章

**自主存取控制和强制存取控制的区别**
（哪一个是对表本身的控制，等等等）
$\qquad$ 自主存取控制能够通过授权机制有效地控制对敏感数据的存取。但是由于用户对于数据的存取权限是“自主”的，用户可以自由地决定将数据的存取权限授予何人，以及决定是否也将“授权”的权限授予别人。

---
# 第五章

**数据库完整性**（实体完整性、参照完整性、用户自定义完整性）**概念** 和 **程序中创建表或视图时完整性约束**怎么写

5.7 触发器（不是机器）

---
# 第六章 （20分）

$\qquad$ 一范式，二范式（2NF），三范式（3NF），BC范式定义（定义，查清依赖，完全依赖还是部份依赖； 查清修改时会发生什么事）
$\qquad$ 比如二范式拆分到BC范式，先阐明为什么满足二范式，写删除修改，更新异常会发生什么，然后写BC范式（即传递依赖）（PPT分析）。

---
# 第七章

E-R图：
$\qquad$ 根据一句话的要求条件建E-R图（搞清楚哪里是“三角，矩形，椭圆，菱形”）
$\qquad$ 画好后转换写成数个关系模式（会设计主码，外码；学会表嵌套）

---
# 第八章 （无大题）

## 8.1.1 定义
## 8.1.2 定义

---
# 第九章 （没有）

查询优化融入第三章

---
# 第十章

## 10.1 事务（概念）
$\qquad$ **事务**是用户定义的一个数据库操作序列，这些操作**要么全做**，**要么全不做**，是一个不可分割的工作单位。例如在关系数据库中，一个事务可以是一条 SQL 语句、一组 SQL 语句或整个程序。
## 10.4 日志文件 （操作）
$\qquad$ 
## 10.5 恢复策略（了解）
$\qquad$ 
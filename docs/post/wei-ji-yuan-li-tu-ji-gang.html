<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark-blue" data-light-theme="dark" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    <script src='https://blog.meekdai.com/Gmeek/plugins/GmeekVercount.js'></script>
    <link rel="icon" href="https://avatars.githubusercontent.com/u/182211636?v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="## 第一章

### 4页 从源程序到能够被计算机执行的程序（以C语言程序为例）

1. **预处理**：在编译器开始实际编译之前，预处理器会根据源代码中的指令（如`#include`、`#define`等）进行文本替换和文件包含操作。">
<meta property="og:title" content="微机原理突击纲">
<meta property="og:description" content="## 第一章

### 4页 从源程序到能够被计算机执行的程序（以C语言程序为例）

1. **预处理**：在编译器开始实际编译之前，预处理器会根据源代码中的指令（如`#include`、`#define`等）进行文本替换和文件包含操作。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://Koi-Blue.github.io/post/wei-ji-yuan-li-tu-ji-gang.html">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/182211636?v=4">
<title>微机原理突击纲</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>
<style>.markdown-alert{padding:0.5rem 1rem;margin-bottom:1rem;border-left:.25em solid var(--borderColor-default,var(--color-border-default));}.markdown-alert .markdown-alert-title {display:flex;font-weight:var(--base-text-weight-medium,500);align-items:center;line-height:1;}.markdown-alert>:first-child {margin-top:0;}.markdown-alert>:last-child {margin-bottom:0;}</style><style>.markdown-alert.markdown-alert-note {border-left-color:var(--borderColor-accent-emphasis, var(--color-accent-emphasis));background-color:var(--color-accent-subtle);}.markdown-alert.markdown-alert-note .markdown-alert-title {color: var(--fgColor-accent,var(--color-accent-fg));}</style><style>.markdown-alert.markdown-alert-tip {border-left-color:var(--borderColor-success-emphasis, var(--color-success-emphasis));background-color:var(--color-success-subtle);}.markdown-alert.markdown-alert-tip .markdown-alert-title {color: var(--fgColor-success,var(--color-success-fg));}</style>



<body>
    <div id="header">
<h1 class="postTitle">微机原理突击纲</h1>
<div class="title-right">
    <a href="https://Koi-Blue.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/Koi-Blue/Koi-Blue.github.io/issues/16" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h2>第一章</h2>
<h3>4页 从源程序到能够被计算机执行的程序（以C语言程序为例）</h3>
<ol>
<li><strong>预处理</strong>：在编译器开始实际编译之前，预处理器会根据源代码中的指令（如<code class="notranslate">#include</code>、<code class="notranslate">#define</code>等）进行文本替换和文件包含操作。最终生成一个融合了头文件内容的纯C语言程序文本文件（<code class="notranslate">.i</code>）。</li>
<li><strong>编译</strong>：编译器将预处理后的<code class="notranslate">.i</code>文件转换为汇编语言程序（<code class="notranslate">.s</code>）。这个过程包括语法分析、语义分析、优化等多个步骤，确保程序逻辑正确并尽可能高效。</li>
<li><strong>汇编</strong>：汇编器将汇编语言程序（<code class="notranslate">.s</code>）转换为机器码形式的目标文件（<code class="notranslate">.o</code>），这些目标文件是二进制格式，但还不是可以直接运行的程序，因为它们可能依赖于其他库函数或模块。</li>
<li><strong>连接</strong>：链接器负责将多个目标文件（<code class="notranslate">.o</code>）以及所需的库文件集成在一起，解决符号引用问题，生成最终的可执行文件（<code class="notranslate">.exe</code>）。这一步骤中，链接器还会处理不同模块之间的地址调整，确保所有部分都能正确协同工作。</li>
</ol>
<h3>18页 什么是嵌入式系统</h3>
<p>嵌入式系统是一种专用于控制、监视或辅助操作机器和设备的专用计算机系统。它通常由以下三部分构成：</p>
<ul>
<li><strong>嵌入式处理器</strong>：核心计算单元，可以是微控制器（MCU）、数字信号处理器（DSP）或其他类型的处理器。</li>
<li><strong>相关硬件设备</strong>：包括传感器、执行器、通信接口等，用于与外部世界交互。</li>
<li><strong>嵌入式软件</strong>：运行在嵌入式处理器上的应用程序，实现特定的功能需求。这类软件通常是实时操作系统（RTOS）或者裸机程序（Bare Metal Programming）。</li>
</ul>
<h3>20页 并发与并行</h3>
<ul>
<li><strong>并发</strong>：指的是在一个时间段内，系统能够处理多个任务的能力。尽管在任何一个给定的时间点上只有一个任务在执行，但由于任务切换速度非常快，从宏观上看就像是多个任务同时进行。在单核CPU上，通过时间片轮转机制来实现多任务的并发执行。</li>
<li><strong>并行</strong>：是指在同一时间点上有多个任务真正地同时执行。要实现真正的并行，必须有多核或多处理器的支持，每个核心或处理器可以独立执行不同的任务。</li>
<li><strong>进程</strong>：是一个独立的执行环境，包含了程序执行所需的所有资源，如内存空间、文件描述符等。一个进程中可以有多个线程作为执行单元，线程共享进程的资源，但在调度时被视为独立的单位。</li>
</ul>
<h3>21页 流水线技术（并行流水线技术）</h3>
<p>流水线技术是现代处理器提高指令吞吐量的关键手段之一。通过将指令的执行过程划分为多个阶段（如取指、解码、执行、访存、写回），并将这些阶段分布在不同的硬件单元中，使得多个指令可以在不同阶段同时进行，从而提高了整体的执行效率。并行流水线技术进一步扩展了这一概念，允许同一时间内多个指令的不同阶段在不同流水线上并行执行。</p>
<h3>27页 进制编码</h3>
<p>BCD（Binary-Coded Decimal）是一种用二进制表示十进制数的方法。最常用的BCD码是8421码，其中每一位二进制位代表十进制数的一个权重（8, 4, 2, 1）。例如，<code class="notranslate">(0010 0011 0100.0001 0101)BCD</code> 对应的十进制数是 <code class="notranslate">234.15</code>。需要注意的是，BCD码只适用于表示0到9的十进制数字，超出这个范围的二进制值对于BCD是非法的。</p>
<h3>33页 补码的运算（进制转换）</h3>
<p>补码是一种用于表示有符号整数的编码方式，广泛应用于计算机系统中。补码的优势在于它可以简化加法和减法运算，避免了对负数的特殊处理。对于n位的二进制数，其补码可以通过对其原码按位取反再加1得到。例如，8位二进制数<code class="notranslate">0000 0010</code>（即十进制2）的补码仍然是<code class="notranslate">0000 0010</code>，而<code class="notranslate">1111 1110</code>（即十进制-2）的补码则是<code class="notranslate">1111 1110</code>。</p>
<h3>37页 运算中的溢出问题，无符号数和有符号数</h3>
<ul>
<li>
<strong>无符号数</strong>：只能表示非负整数，范围是从0到 $2^n - 1$ ，其中n是位数。</li>
<li>
<strong>有符号数</strong>：可以表示正数和负数，范围取决于使用的编码方式（如补码）。对于n位的补码表示，范围是从 $-2^{n-1}$ 到 $2^{n-1} - 1$ 。</li>
<li>
<strong>溢出</strong>：当运算结果超出了数据类型所能表示的范围时，就会发生溢出。对于无符号数，溢出会导致结果“环绕”；而对于有符号数，溢出可能会导致错误的结果，因此需要特别注意检测和处理。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/17787ba44dfabcd9618c426e6b47c3541e7333e9a01757fe2c53786ee6068ee2/68747470733a2f2f73322e6c6f6c692e6e65742f323032342f31322f30362f3547645074766134463163697875712e706e67"><img src="https://camo.githubusercontent.com/17787ba44dfabcd9618c426e6b47c3541e7333e9a01757fe2c53786ee6068ee2/68747470733a2f2f73322e6c6f6c692e6e65742f323032342f31322f30362f3547645074766134463163697875712e706e67" alt="微机1.png" data-canonical-src="https://s2.loli.net/2024/12/06/5GdPtva4F1cixuq.png" style="max-width: 100%;"></a><br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/436caed78fb9782bd2594335366ad0f03582dddba31277f8bab0566a3775696b/68747470733a2f2f73322e6c6f6c692e6e65742f323032342f31322f30362f734f64655366746747684e75566e332e706e67"><img src="https://camo.githubusercontent.com/436caed78fb9782bd2594335366ad0f03582dddba31277f8bab0566a3775696b/68747470733a2f2f73322e6c6f6c692e6e65742f323032342f31322f30362f734f64655366746747684e75566e332e706e67" alt="微机2.png" data-canonical-src="https://s2.loli.net/2024/12/06/sOdeSftgGhNuVn3.png" style="max-width: 100%;"></a></p>
<h3>41页 基本逻辑门</h3>
<p>基本逻辑门是构建数字电路的基础元件，常见的逻辑门包括：</p>
<ul>
<li><strong>与门（AND Gate）</strong>：只有当所有输入都为高电平时，输出才为高电平。</li>
<li><strong>或门（OR Gate）</strong>：只要有一个输入为高电平，输出就为高电平。</li>
<li><strong>与非门（NAND Gate）</strong>：与门的反相输出，即只要有一个输入为低电平，输出就为高电平。</li>
<li><strong>或非门（NOR Gate）</strong>：或门的反相输出，即只有当所有输入都为低电平时，输出才为高电平。</li>
<li><strong>异或门（XOR Gate）</strong>：当两个输入不同时，输出为高电平；当两个输入相同时，输出为低电平。</li>
<li><strong>同或门（XNOR Gate）</strong>：异或门的反相输出，即当两个输入相同时，输出为高电平；当两个输入不同时，输出为低电平。</li>
</ul>
<h3>44页 三八译码器</h3>
<p>三八译码器（3-to-8 Line Decoder）是一种常用的数字电路，用于将3位二进制输入转换为8个单独的输出线。它的主要功能是根据输入的3位二进制码选择一个对应的输出线激活（高电平），其余输出线保持低电平。三八译码器通常具有使能端（Enable），只有当使能端为有效状态时，译码器才会工作。常见的应用包括地址译码、控制信号分配等。</p>
<h2>第二章</h2>
<h3>53页 多核技术</h3>
<p>多核技术是指在一个处理器芯片内部集成多个独立的核心（Core），每个核心都可以独立执行程序。多核处理器的优点包括：</p>
<ul>
<li>提高并行处理能力，支持更多的任务同时运行。</li>
<li>降低功耗，相比单核处理器，在相同性能下可以更节能。</li>
<li>改善响应速度，特别是在多任务环境下，可以更好地满足实时性要求。</li>
</ul>
<h3>57页 8086/8088</h3>
<h4>2.2 x86处理器特点</h4>
<ul>
<li><strong>流水线</strong>：8086/8088处理器采用了简单的流水线结构，主要包括取指、解码、执行三个阶段。流水线技术提高了指令的吞吐量，但也会引入一些复杂性，如分支预测和异常处理。</li>
<li><strong>内存分段</strong>：8086/8088使用了分段内存模型，将内存分为多个逻辑段，如代码段（CS）、数据段（DS）、堆栈段（SS）等。每个段都有自己的基地址和长度，通过段寄存器来管理和访问。</li>
<li><strong>支持多处理器</strong>：虽然8086/8088本身是单核处理器，但它可以通过外设（如APIC）支持多处理器系统，允许多个处理器协同工作。</li>
</ul>
<h3>62页 8086/8088内部寄存器</h3>
<p>8086/8088处理器共有14个16位寄存器，分为以下几类：</p>
<ul>
<li><strong>通用寄存器</strong>：AX、BX、CX、DX，用于存储数据和地址。</li>
<li><strong>指针寄存器</strong>：SP（堆栈指针）、BP（基址指针），用于管理堆栈和数据访问。</li>
<li><strong>索引寄存器</strong>：SI（源索引）、DI（目的索引），用于数组和字符串操作。</li>
<li><strong>段寄存器</strong>：CS（代码段）、DS（数据段）、SS（堆栈段）、ES（附加段），用于分段内存管理。</li>
<li><strong>指令指针</strong>：IP（指令指针），指向当前正在执行的指令。</li>
<li><strong>标志寄存器</strong>：FLAGS，包含多个标志位，用于表示运算结果的状态（如零标志、进位标志等）。</li>
</ul>
<h3>64页 控制寄存器</h3>
<p>在x86架构中，<strong>Flags标志寄存器</strong>（通常简称为<code class="notranslate">FLAGS</code>）是一个16位的寄存器，用于保存CPU的各种状态和控制信息。它分为两类标志位：<strong>状态标志位</strong>和<strong>控制标志位</strong>。以下是详细的说明：</p>
<h4>状态标志位</h4>
<p>状态标志位反映了最近一次算术或逻辑操作的结果，用于条件转移指令和其他需要根据操作结果做出决策的地方。</p>
<ul>
<li>
<p><strong>CF (Carry Flag, 进位/借位标志)</strong>：</p>
<ul>
<li>当无符号数运算产生进位或借位时设置为1，否则为0。</li>
<li>例如，在加法操作中，如果最高有效位产生了进位，则CF=1；在减法操作中，如果发生了借位，则CF=1。</li>
</ul>
</li>
<li>
<p><strong>PF (Parity Flag, 奇偶标志)</strong>：</p>
<ul>
<li>表示结果的最低8位中1的数量是偶数还是奇数。</li>
<li>如果1的数量是偶数，则PF=1；如果是奇数，则PF=0。</li>
<li>主要用于某些特定类型的校验。</li>
</ul>
</li>
<li>
<p><strong>AF (Auxiliary Flag, 辅助进位标志)</strong>：</p>
<ul>
<li>在BCD调整指令中使用，表示低4位是否有进位或借位。</li>
<li>如果在第3位到第4位之间有进位或借位，则AF=1；否则为0。</li>
</ul>
</li>
<li>
<p><strong>ZF (Zero Flag, 零标志)</strong>：</p>
<ul>
<li>如果操作结果为0，则ZF=1；否则为0。</li>
<li>常用于判断两个数是否相等或是否为零。</li>
</ul>
</li>
<li>
<p><strong>SF (Sign Flag, 符号标志)</strong>：</p>
<ul>
<li>反映结果的最高有效位（即符号位），用于表示有符号数的正负。</li>
<li>如果最高有效位为1（表示负数），则SF=1；如果为0（表示正数），则SF=0。</li>
</ul>
</li>
<li>
<p><strong>OF (Overflow Flag, 溢出标志)</strong>：</p>
<ul>
<li>当有符号数运算结果超出可表示范围时设置为1，否则为0。</li>
<li>例如，在带符号整数加法中，如果结果超出了可以表示的最大或最小值，则OF=1。</li>
</ul>
</li>
</ul>
<h4>控制标志位</h4>
<p>控制标志位影响CPU的操作模式和行为，主要用于调试、中断处理和字符串操作。</p>
<ul>
<li>
<p><strong>TF (Trap Flag, 捕捉标志)</strong>：</p>
<ul>
<li>当设置为1时，启用单步调试模式。每执行一条指令后，CPU会触发一个单步中断（INT 1），允许程序员逐条检查程序执行情况。</li>
<li>通常用于开发和调试过程中。</li>
</ul>
</li>
<li>
<p><strong>IF (Interrupt Flag, 中断允许标志)</strong>：</p>
<ul>
<li>控制外部可屏蔽中断的允许或禁止。</li>
<li>IF=1时，允许外部中断；IF=0时，禁止外部中断。</li>
<li>可以通过CLI（清除中断标志）和STI（设置中断标志）指令来改变IF的状态。</li>
</ul>
</li>
<li>
<p><strong>DF (Direction Flag, 方向标志)</strong>：</p>
<ul>
<li>决定字符串操作指令（如<code class="notranslate">MOVS</code>、<code class="notranslate">SCAS</code>等）的处理方向。</li>
<li>DF=0时，字符串操作从低地址向高地址进行（增量模式）；DF=1时，字符串操作从高地址向低地址进行（减量模式）。</li>
<li>可以通过CLD（清除方向标志）和STD（设置方向标志）指令来改变DF的状态。</li>
</ul>
</li>
</ul>
<h3>67页 段寄存器的组合规则</h3>
<p>段寄存器用于分段内存管理，每个段寄存器对应一个逻辑段。段寄存器的组合规则如下：</p>
<ul>
<li><strong>代码段（CS）</strong>：用于存放指令代码，通过CS:IP访问。</li>
<li><strong>数据段（DS）</strong>：用于存放数据，通过DS:BX、DS:SI等访问。</li>
<li><strong>堆栈段（SS）</strong>：用于管理堆栈，通过SS:SP访问。</li>
<li><strong>附加段（ES）</strong>：用于额外的数据访问，通常用于字符串操作，通过ES:DI访问。</li>
</ul>
<h3>70页 时钟周期，总线周期概念</h3>
<ul>
<li><strong>时钟周期</strong>：是处理器的基本时间单位，由时钟信号决定。每个时钟周期内，处理器可以完成一个基本的操作，如取指、解码等。</li>
<li><strong>总线周期</strong>：是指处理器与外部设备（如内存、I/O端口）进行一次数据传输所需的时间。一个总线周期通常由多个时钟周期组成，具体取决于总线的速度和负载情况。</li>
</ul>
<h3>71页 图2-12 引脚作用</h3>
<p>在8086/8088处理器中，引脚的作用非常重要，尤其是在与外部设备通信时。图2-12展示了8086/8088的主要引脚及其作用，其中包括：</p>
<ul>
<li><strong>地址总线（A0-A19）</strong>：用于发送地址信号，指定要访问的内存或I/O端口地址。</li>
<li><strong>数据总线（D0-D15）</strong>：用于传输数据，8088为8位数据总线，8086为16位数据总线。</li>
<li><strong>控制总线</strong>：包括读/写信号（RD、WR）、中断请求（INT）、复位信号（RESET）等，用于控制处理器的行为。</li>
<li><strong>等待周期（TW）</strong>：当外部设备无法及时响应时，处理器会插入等待周期，以确保数据传输的正确性。</li>
</ul>
<h2>第三章</h2>
<h3>114页 寻址方式</h3>
<p>寻址方式决定了如何获取指令的操作数。常见的寻址方式包括：</p>
<ul>
<li>
<p><strong>立即数寻址</strong>：操作数直接出现在指令中，不需要访问内存。</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">MOV</span><span class="pl-en"> </span><span class="pl-v">AX</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">1234H</span><span class="pl-c">     ; 把立即数 1234H 装入 AX</span></pre></div>
</li>
<li>
<p><strong>寄存器寻址</strong>：操作数存放在寄存器中，指令直接指定寄存器编号。</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">MOV</span><span class="pl-en"> </span><span class="pl-v">BX</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">AX</span><span class="pl-c">     ; 把 AX 的值传递（复制）给 BX</span></pre></div>
</li>
<li>
<p><strong>直接寻址</strong>：操作数存放在内存中，指令中给出内存地址。</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">MOV</span><span class="pl-en"> </span><span class="pl-v">AX</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-s1">[</span><span class="pl-c1">1234H</span><span class="pl-s1">]</span><span class="pl-c">     ; 从内存地址 1234H 取数据装入 AX</span></pre></div>
</li>
<li>
<p><strong>间接寻址</strong>：操作数存放在内存中，指令中给出一个地址指针，通过该指针访问内存中的操作数。</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">MOV</span><span class="pl-en"> </span><span class="pl-v">AX</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-s1">[</span><span class="pl-v">BX</span><span class="pl-s1">]</span><span class="pl-c">    ; BX 中存储的是地址，通过 BX 取出该地址上的数据</span></pre></div>
</li>
<li>
<p><strong>基址寻址</strong>：操作数存放在内存中，指令中给出一个偏移量，通过基址寄存器加上偏移量计算出实际地址。</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">MOV</span><span class="pl-en"> </span><span class="pl-v">AX</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-s1">[</span><span class="pl-v">BX</span><span class="pl-en"> </span><span class="pl-s1">+</span><span class="pl-en"> </span><span class="pl-c1">04H</span><span class="pl-s1">]</span><span class="pl-c">    ; 基址 BX 加偏移量 04H，找到操作数</span></pre></div>
</li>
<li>
<p><strong>变址寻址</strong>：操作数存放在内存中，指令中给出一个偏移量，通过变址寄存器加上偏移量计算出实际地址。</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">MOV</span><span class="pl-en"> </span><span class="pl-v">AX</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-s1">[</span><span class="pl-v">SI</span><span class="pl-en"> </span><span class="pl-s1">+</span><span class="pl-en"> </span><span class="pl-c1">08H</span><span class="pl-s1">]</span><span class="pl-c">    ; 变址 SI 加偏移量 08H，找到操作数</span></pre></div>
</li>
<li>
<p><strong>相对寻址</strong>：操作数存放在内存中，指令中给出一个相对偏移量，通过当前指令指针加上偏移量计算出实际地址。</p>
</li>
</ul>
<p>（不需要计算物理地址：立即数寻址和寄存器寻址）</p>
<p>寻址方式判断和求寄存器内容可以读<a href="https://blog.csdn.net/weixin_44015158/article/details/111937895" rel="nofollow">这篇文章</a>。</p>
<h3>124页 指令对操作数的要求</h3>
<p>（判断指令正确与否）<br>
堆栈操作的指令 push pop</p>
<p>在x86指令集中，指令对操作数的要求非常严格，必须遵循一定的规则。例如：</p>
<ul>
<li>
<p><strong>单操作数指令</strong>：如<code class="notranslate">PUSH</code>、<code class="notranslate">POP</code>等，操作数可以是寄存器或内存地址。</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">PUSH</span><span class="pl-en"> </span><span class="pl-v">AX</span><span class="pl-c">    ; 将 AX 的内容压入堆栈</span>
<span class="pl-k">POP</span><span class="pl-en"> </span><span class="pl-v">BX</span><span class="pl-c">     ; 从堆栈弹出数据到 BX</span></pre></div>
<blockquote>
<p><strong>注意</strong>：PUSH 和 POP 的操作数只能是寄存器或内存，不能是立即数。</p>
</blockquote>
</li>
<li>
<p><strong>双操作数指令</strong>：如<code class="notranslate">MOV</code>、<code class="notranslate">ADD</code>等，通常第一个操作数为目标操作数，第二个操作数为源操作数。目标操作数可以是寄存器或内存地址，源操作数可以是寄存器、内存地址或立即数。</p>
</li>
<li>
<p><strong>指针运算符</strong>：如<code class="notranslate">PTR</code>，用于明确指定操作数的大小（字节、字、双字等），确保指令正确解析。</p>
</li>
</ul>
<h3>125页 为什么要用堆栈</h3>
<p>（一个保护断点（地址压入堆栈），一个保护现场），堆栈的原则（*）</p>
<p>堆栈是一种后进先出（LIFO）的数据结构，广泛应用于程序执行过程中。堆栈的主要用途包括：</p>
<ul>
<li><strong>保护断点</strong>：当调用子程序时，返回地址会被压入堆栈，以便子程序执行完毕后能够正确返回到调用点。</li>
<li><strong>保护现场</strong>：在中断处理或函数调用时，保存当前的寄存器状态，确保恢复后程序能够继续正常执行。</li>
<li><strong>参数传递</strong>：在函数调用时，参数可以压入堆栈，供被调用函数使用。</li>
<li><strong>局部变量存储</strong>：函数内部的局部变量通常也存储在堆栈中，便于动态分配和释放。</li>
</ul>
<h3>126页 图3-14，图3-15</h3>
<h3>128页 第一段第一二行：设置堆栈的原因</h3>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p>堆栈除了在子程序调用和相应中断时用于保护断点地址外，还可以需要时对某些寄存器内容进行保存</p>
</div>
<blockquote>
<p>设置堆栈的原因主要是为了提供一种灵活且高效的机制来管理函数调用、中断处理和局部变量。通过堆栈，程序可以方便地保存和恢复上下文信息，确保程序的正确性和稳定性。常见的设置堆栈指令包括<code class="notranslate">PUSH</code>、<code class="notranslate">POP</code>、<code class="notranslate">LEA</code>等。</p>
</blockquote>
<h3>130页 输入输出指令</h3>
<p>输入输出指令用于与外部设备进行通信。常见的输入输出指令包括：</p>
<ul>
<li>
<p><strong>IN</strong>：从指定的I/O端口读取数据，存入寄存器（如AL、AX）。</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">IN</span><span class="pl-en"> </span><span class="pl-v">AL</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">60H</span><span class="pl-c">    ;从端口 60H 读取数据到 AL</span></pre></div>
</li>
<li>
<p><strong>OUT</strong>：将寄存器（如AL、AX）中的数据写入指定的I/O端口。</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">OUT</span><span class="pl-en"> </span><span class="pl-c1">60H</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">AL</span><span class="pl-c">    ;将 AL 中的数据写到端口 60H</span></pre></div>
</li>
<li>
<p><strong>DX寄存器</strong>：当I/O端口地址超过8位时，使用DX寄存器存放高8位地址，AL或AX存放低8位或16位地址。</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">MOV</span><span class="pl-en"> </span><span class="pl-v">DX</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">60H</span>
<span class="pl-k">IN</span><span class="pl-en"> </span><span class="pl-v">AL</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">DX</span><span class="pl-c">    ;通过 DX 指定端口读取数据到 AL</span></pre></div>
</li>
</ul>
<h3>134页 减法指令</h3>
<p>减法指令用于执行减法运算，常见的减法指令包括：</p>
<ul>
<li><strong>SUB</strong>：从目标操作数中减去源操作数，结果存入目标操作数。</li>
<li><strong>SBB</strong>：带借位的减法，从目标操作数中减去源操作数和进位标志（CF），结果存入目标操作数。SBB常用于多字节减法运算。</li>
</ul>
<h3>136页 比较指令 cmp</h3>
<p>比较指令<code class="notranslate">CMP</code>用于比较两个操作数的大小，但不会保存结果，而是通过修改标志寄存器（FLAGS）中的标志位来反映比较结果。<code class="notranslate">CMP</code>实际上相当于执行了一次减法操作，但不改变操作数的值。例如：</p>
<ul>
<li><code class="notranslate">CMP AX, BX</code>：比较AX和BX的值，更新标志寄存器中的零标志（ZF）、符号标志（SF）、进位标志（CF）等。</li>
</ul>
<h3>140页 逻辑与指令</h3>
<p>逻辑与指令<code class="notranslate">AND</code>用于执行按位与运算，常用于屏蔽某些位或清除特定位。<code class="notranslate">AND</code>指令的操作数可以是寄存器、内存地址或立即数。例如：</p>
<ul>
<li><code class="notranslate">AND AL, 0F0H</code>：将AL寄存器的低4位清零，保留高4位。</li>
</ul>
<h3>142页 测试指令 test</h3>
<p>测试指令<code class="notranslate">TEST</code>类似于<code class="notranslate">AND</code>指令，但它不会保存结果，而是通过修改标志寄存器中的标志位来反映测试结果。<code class="notranslate">TEST</code>常用于检查某些位是否为1或0。例如：</p>
<ul>
<li><code class="notranslate">TEST AL, 01H</code>：检查AL寄存器的最低位是否为1，更新零标志（ZF）。</li>
</ul>
<h3>143页 逻辑左移和算术左移</h3>
<ul>
<li><strong>逻辑左移（SHL）</strong>：将操作数的每一位向左移动指定的位数，空出的低位用0填充。逻辑左移常用于乘法运算（如乘以2的幂）。</li>
<li><strong>算术左移（SAL）</strong>：与逻辑左移相同，但在处理有符号数时，算术左移会保留符号位，确保结果的符号正确。SAL和SHL在x86指令集中实际上是相同的指令，但对于有符号数的处理，推荐使用SAL。</li>
</ul>
<h2>第四章</h2>
<h3>184页 取值运算符</h3>
<p>取值运算符用于获取变量的值或地址。常见的取值运算符包括：</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d2c0ecd6fffd9af4e40bc5ec4f1b5cba7fab9d896c40d3b1e005648dc600d2a1/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353037366438356632352e706e67"><img src="https://camo.githubusercontent.com/d2c0ecd6fffd9af4e40bc5ec4f1b5cba7fab9d896c40d3b1e005648dc600d2a1/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353037366438356632352e706e67" alt="1733626089683.png" data-canonical-src="https://www.helloimg.com/i/2024/12/08/6755076d85f25.png" style="max-width: 100%;"></a></p>
<h3>185页 伪指令（操作码）</h3>
<p>4.2 伪指令不是真正的机器指令，而是汇编器用来指导汇编过程的指令。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/36b042a405e945e70e95b00d508fb714ac07fdcd1250240be2f60e1f6d7d0c95/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353061653263633337342e706e67"><img src="https://camo.githubusercontent.com/36b042a405e945e70e95b00d508fb714ac07fdcd1250240be2f60e1f6d7d0c95/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353061653263633337342e706e67" alt="1733626981851.png" data-canonical-src="https://www.helloimg.com/i/2024/12/08/67550ae2cc374.png" style="max-width: 100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ccb83e7264d41cb377b190e41f58151b46a3a6d3a9a99f0e077cb0f0971fa0ba/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353038336132616464642e706e67"><img src="https://camo.githubusercontent.com/ccb83e7264d41cb377b190e41f58151b46a3a6d3a9a99f0e077cb0f0971fa0ba/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353038336132616464642e706e67" alt="微机3.png" data-canonical-src="https://www.helloimg.com/i/2024/12/08/6755083a2addd.png" style="max-width: 100%;"></a></p>
<p>常见的伪指令包括：</p>
<ul>
<li><strong>SECTION</strong>：定义代码段或数据段。</li>
<li><strong>EXTERN</strong>：声明外部符号，表示该符号将在其他文件中定义。</li>
<li><strong>GLOBAL</strong>：声明全局符号，表示该符号可以在其他文件中引用。</li>
<li><strong>DB/DW/DD</strong>：定义字节、字、双字的数据。</li>
<li><strong>EQU</strong>：定义常量，如<code class="notranslate">SIZE EQU 10</code>。</li>
</ul>
<h3>186页 例4-3</h3>
<p>变量在内存中的存放顺序<br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/1b3ca313d95414cbe2483ab0215b32d6db53cb90a541f901669d22448cc9989d/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353062343638623735362e706e67"><img src="https://camo.githubusercontent.com/1b3ca313d95414cbe2483ab0215b32d6db53cb90a541f901669d22448cc9989d/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353062343638623735362e706e67" alt="1733627081470.png" data-canonical-src="https://www.helloimg.com/i/2024/12/08/67550b468b756.png" style="max-width: 100%;"></a></p>
<h3>197页 DOS系统功能调用方法</h3>
<p>DOS系统功能调用是通过中断（INT 21H）来实现的。调用时，程序需要设置AH寄存器为功能号，并根据具体功能设置其他寄存器或内存中的参数。例如：</p>
<ul>
<li><code class="notranslate">INT 21H, AH=09H</code>：显示字符串，字符串地址存放在DX寄存器中。</li>
</ul>
<h3>203页 2 的4567</h3>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/898a14b4291e7b48cef4e41cd227188395100f049a6c371ec21202a0acf56467/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353062633863313839332e706e67"><img src="https://camo.githubusercontent.com/898a14b4291e7b48cef4e41cd227188395100f049a6c371ec21202a0acf56467/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353062633863313839332e706e67" alt="1733627209279.png" data-canonical-src="https://www.helloimg.com/i/2024/12/08/67550bc8c1893.png" style="max-width: 100%;"></a></p>
<div class="markdown-alert markdown-alert-tip"><p class="markdown-alert-title"><svg class="octicon octicon-light-bulb mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p><p>这部分内容需要详细回答。</p>
</div>
<h2>第五章</h2>
<h3>226页 6264芯片</h3>
<p>6264是一款静态随机存取存储器（SRAM），具有8K×8的存储容量。它的地址线为A0-A12（共13根），可以寻址8192个地址；数据线为D0-D7（共8根），每次可以读写8位数据。SRAM的特点是速度快、无需刷新，但功耗较高，适合用于缓存或高速缓冲区。</p>
<h3>230页 DRAM刷新</h3>
<p>动态随机存取存储器（DRAM）由于其存储单元的电容特性，需要定期刷新以保持数据的完整性。刷新操作通常由内存控制器自动完成，每隔一定时间（如64ms）对所有行进行一次刷新。刷新操作会影响系统的性能，因此现代DRAM采用了多种优化技术，如自刷新模式、分布式刷新等。</p>
<h3>231页 地址译码的方式</h3>
<p>地址译码是将CPU发出的地址信号转换为具体的物理地址，以便正确访问内存或I/O端口。常见的地址译码方式包括：</p>
<ul>
<li><strong>全地址译码</strong>：所有地址线都参与译码，确保每个地址唯一对应一个存储单元或I/O端口。</li>
<li><strong>部分地址译码</strong>：只有部分地址线参与译码，可能导致地址重叠，适用于简单的系统或小规模存储器。</li>
</ul>
<h3>233页 仅用一位的线选译码</h3>
<p>线选译码是一种简单的地址译码方式，通常用于选择一组存储器芯片或I/O端口。例如，使用一个使能信号（如CS）来选择一组8K×8的SRAM芯片，而不对每个芯片进行单独的地址译码。这种方式简单易实现，但灵活性较差。</p>
<h3>234页 例5-1</h3>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5fad6699225f3d1d04dac102344ccef4b2adeb17e8367ab6db4ddc3e9303542b/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353063633731393162322e706e67"><img src="https://camo.githubusercontent.com/5fad6699225f3d1d04dac102344ccef4b2adeb17e8367ab6db4ddc3e9303542b/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353063633731393162322e706e67" alt="1733627465736.png" data-canonical-src="https://www.helloimg.com/i/2024/12/08/67550cc7191b2.png" style="max-width: 100%;"></a></p>
<p><strong>各种ROM的名字和特性</strong><br>
常见的只读存储器（ROM）类型包括：</p>
<ul>
<li><strong>EPROM（可擦除可编程只读存储器）</strong>：可以通过紫外线擦除数据，重新编程。</li>
<li><strong>EEPROM(E<sup>2</sup>PROM)（电可擦除可编程只读存储器）</strong>：可以通过电信号擦除和编程，支持字节级别的擦写操作。</li>
<li><strong>Flash ROM</strong>：一种特殊的EEPROM，支持大块数据的快速擦除和编程，广泛应用于固件存储。</li>
<li><strong>PROM（可编程只读存储器）</strong>：只能编程一次，一旦写入数据后无法更改。</li>
</ul>
<h3>236(?)页 SRAM（特点）   DRAM</h3>
<h3>239页 EEPROM擦除</h3>
<p>EEPROM的擦除操作是通过施加特定的电压或电流来实现的。擦除过程通常比编程过程慢得多，且有一定的寿命限制（如10万次擦写周期）。擦除操作可以针对整个芯片或单个字节进行，具体取决于EEPROM的类型和设计。</p>
<h3>244页 存储器扩展技术</h3>
<p>存储器扩展技术用于增加系统的存储容量，常见的扩展方式包括：</p>
<ul>
<li><strong>字扩展</strong>：通过增加数据线的数量来扩展存储器的位宽。例如，将两片8位SRAM芯片并联，形成16位的存储器。</li>
<li><strong>位扩展</strong>：通过增加地址线的数量来扩展存储器的地址空间。例如，将两片8K×8的SRAM芯片串联，形成16K×8的存储器。</li>
<li><strong>字位扩展</strong>：同时进行字扩展和位扩展，以达到更大的存储容量。</li>
</ul>
<h3>246页 例5-4</h3>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/658680fd06bb60796be57ca97ae6e553475a4563e426d963508ba4f3756da9aa/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353064383261353234322e706e67"><img src="https://camo.githubusercontent.com/658680fd06bb60796be57ca97ae6e553475a4563e426d963508ba4f3756da9aa/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353064383261353234322e706e67" alt="1733627635231.png" data-canonical-src="https://www.helloimg.com/i/2024/12/08/67550d82a5242.png" style="max-width: 100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/79703da1e60cc189fc72d465a02a680f83a873a76aed726ab9a3fda255d08fb5/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353064383264616366652e706e67"><img src="https://camo.githubusercontent.com/79703da1e60cc189fc72d465a02a680f83a873a76aed726ab9a3fda255d08fb5/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353064383264616366652e706e67" alt="1733627652573.png" data-canonical-src="https://www.helloimg.com/i/2024/12/08/67550d82dacfe.png" style="max-width: 100%;"></a></p>
<h3>247页 例5-5</h3>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/38b9e00d9707ad83007b7bd30817927cb7e4a2b06c7c3b22644989d688537cc0/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353064616162613335632e706e67"><img src="https://camo.githubusercontent.com/38b9e00d9707ad83007b7bd30817927cb7e4a2b06c7c3b22644989d688537cc0/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353064616162613335632e706e67" alt="1733627693629.png" data-canonical-src="https://www.helloimg.com/i/2024/12/08/67550daaba35c.png" style="max-width: 100%;"></a></p>
<h3>249页 例5-7</h3>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/85d9f16f6300e70a48a5dfb71550f59f19e4fa9f94545cc5c6df1896bee6b591/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353064643161616130302e706e67"><img src="https://camo.githubusercontent.com/85d9f16f6300e70a48a5dfb71550f59f19e4fa9f94545cc5c6df1896bee6b591/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353064643161616130302e706e67" alt="1733627733362.png" data-canonical-src="https://www.helloimg.com/i/2024/12/08/67550dd1aaa00.png" style="max-width: 100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3721bda56d753683f932e425cc09d6c93a9d17c28dea14abfb71a5e4c33914c4/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353065303364323339612e706e67"><img src="https://camo.githubusercontent.com/3721bda56d753683f932e425cc09d6c93a9d17c28dea14abfb71a5e4c33914c4/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353065303364323339612e706e67" alt="1733627783149.png" data-canonical-src="https://www.helloimg.com/i/2024/12/08/67550e03d239a.png" style="max-width: 100%;"></a></p>
<blockquote>
<p>计算存储器的容量。公式为：<code class="notranslate">容量 = (末地址 - 首地址 + 1)</code>。理解存储器地址空间的计算方法。</p>
</blockquote>
<h3>259页 作业第七题</h3>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/f16112967763eff480ed37bbd0b12184c2b10a8db3263fa8c5b45693e29fdbe0/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353065333935616634352e706e67"><img src="https://camo.githubusercontent.com/f16112967763eff480ed37bbd0b12184c2b10a8db3263fa8c5b45693e29fdbe0/68747470733a2f2f7777772e68656c6c6f696d672e636f6d2f692f323032342f31322f30382f363735353065333935616634352e706e67" alt="1733627837175.png" data-canonical-src="https://www.helloimg.com/i/2024/12/08/67550e395af45.png" style="max-width: 100%;"></a></p>
<h2>第六章</h2>
<h3>265页 IO端口编址</h3>
<p>IO端口编址是指为I/O设备分配唯一的地址，以便CPU能够正确访问这些设备。常见的IO端口编址方式包括：</p>
<ul>
<li><strong>独立编址</strong>：I/O端口与内存地址分开编址，使用专门的指令（如IN、OUT）进行访问。8086/8088处理器支持64K个I/O端口地址（0000H-FFFFH）。</li>
<li><strong>统一编址</strong>：I/O端口与内存地址统一编址，使用相同的指令（如MOV）进行访问。这种方式简化了编程，但减少了可用的内存地址空间。</li>
</ul>
<h3>6.2 输入接口和输出接口</h3>
<p>输入接口和输出接口是连接CPU与外部设备的桥梁，它们负责数据的传输和控制。输入接口的主要功能是接收来自外部设备的数据，输出接口的主要功能是将数据发送到外部设备。常见的输入接口和输出接口包括：</p>
<ul>
<li><strong>锁存器</strong>：用于暂时保存数据，确保数据的稳定传输。</li>
<li><strong>控制寄存器</strong>：用于配置接口的工作模式和状态。</li>
</ul>
<h3>272页 基本输入输出方式</h3>
<p>常见的输入输出方式包括：</p>
<ul>
<li><strong>程序控制I/O</strong>：CPU通过执行程序指令直接控制I/O操作，适用于简单的I/O设备。</li>
<li><strong>中断驱动I/O</strong>：I/O设备通过中断请求通知CPU，CPU在适当的时候处理I/O请求，适用于需要及时响应的设备。</li>
<li><strong>DMA（直接内存访问）</strong>：I/O设备通过DMA控制器直接与内存进行数据传输，无需CPU干预，适用于大数据量的传输。</li>
<li><strong>通道程序</strong>：通过专门的I/O处理器执行I/O操作，适用于复杂的I/O任务。</li>
</ul>
<h3>276页 DMA控制功能</h3>
<p>DMA（Direct Memory Access）是一种高效的数据传输方式，允许I/O设备直接与内存进行数据交换，而无需CPU的介入。DMA控制器负责管理数据传输的过程，确保数据的正确性和完整性。DMA特别适用于需要高速数据传输的场景，如磁盘读写、网络通信等。</p>
<h3>279页 中断源</h3>
<p>中断源是指触发中断请求的来源，分为内部中断和外部中断：</p>
<ul>
<li><strong>内部中断</strong>：由CPU内部事件触发，如除法错误、非法指令等。</li>
<li><strong>外部中断</strong>：由外部设备触发，如键盘按下、定时器超时等。</li>
</ul>
<p>中断服务过程包括以下几个步骤：</p>
<ol>
<li><strong>中断请求</strong>：外部设备或内部事件触发中断请求。</li>
<li><strong>中断响应</strong>：CPU暂停当前任务，保存上下文信息（如寄存器状态）。</li>
<li><strong>中断服务</strong>：CPU跳转到中断服务程序（ISR），执行相应的处理逻辑。</li>
<li><strong>中断返回</strong>：中断服务程序执行完毕后，CPU恢复上下文信息，继续执行原任务。</li>
</ol>
<h3>284页 图6-23下</h3>
<p>中断向量是中断服务程序的入口地址，通常由四个字节组成，前两个字节表示偏移地址（IP），后两个字节表示段地址（CS）。在实模式下，每个中断向量占用4个字节，总共可以容纳256个中断向量（0-255）。</p>
<h3>289页 8259</h3>
<p>8259是一款可编程中断控制器，用于管理多个中断源。通过级联多个8259芯片，可以扩展系统的中断处理能力。例如，9片8259芯片可以管理最多64个中断源。8259的主要功能包括：</p>
<ul>
<li><strong>优先级管理</strong>：根据中断源的优先级，决定哪个中断先被处理。</li>
<li><strong>中断屏蔽</strong>：通过设置屏蔽寄存器，可以选择性地禁止某些中断源。</li>
<li><strong>中断结束</strong>：在中断服务程序执行完毕后，通知8259中断已处理完毕。</li>
</ul>
<h3>294页 级联工作方式</h3>
<p>级联工作方式是指通过多个8259芯片的级联，扩展系统的中断处理能力。例如，4片8259芯片可以管理29个中断源（4×8−3）。级联工作方式的实现涉及到主从关系的配置、中断优先级的设定以及中断传递的机制。</p>
<h2>第七章</h2>
<h3>8253/8255</h3>
<p>8253是一款可编程定时器/计数器，广泛应用于定时、延时、频率测量等场景。8255是一款可编程并行接口芯片，用于实现CPU与外部设备之间的并行数据传输。两者都是嵌入式系统中常用的重要组件。</p>
<h3>326页 8253方式3</h3>
<p>8253的工作方式3是一种方波发生器模式，用于生成连续的方波信号。在这种模式下，8253会在计数值到达0时自动重新加载初始值，并继续计数。方波的频率取决于计数值和时钟频率。方式3常用于产生定时脉冲或同步信号。</p>
<h3>例7-1</h3>
<p>例7-1</p>
<h3>338页 8255工作方式</h3>
<p>8255有三种工作方式，分别适用于不同的应用场景：</p>
<ul>
<li><strong>方式0（基本输入/输出）</strong>：提供简单的并行输入和输出功能，适用于不需要握手信号的基本I/O操作。</li>
<li><strong>方式1（选通输入/输出）</strong>：增加了握手信号的支持，允许更复杂的I/O操作，如确认接收或发送完成。</li>
<li><strong>方式2（双向数据传送）</strong>：支持双向数据传送，并且具有自动握手能力，适合用于需要高速数据交换的应用场景。</li>
</ul>
<p>每个端口（A、B、C）都可以独立配置为上述任何一种工作模式，或者组合使用，以满足不同外设的要求。</p></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://Koi-Blue.github.io">Koi_Blue</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("07/31/2024"!=""){
    var startSite=new Date("07/31/2024");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","Koi-Blue/Koi-Blue.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://blog.meekdai.com/Gmeek/plugins/articletoc.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script><script>MathJax = {tex: {inlineMath: [["$", "$"]]}};</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</html>
